# 10. Batch Processing
[english](10-batch-processing.md) | russian

**TL;DR:** Batch-обработка: от Unix-пайплайнов до MapReduce и DAG-движков; почему сортировка/shuffle фундаментальны для join и GROUP BY, и как устроены надежность и производные данные.

---

## Batch Processing

- Batch — обработка конечного набора данных батчами: высокая пропускная способность и воспроизводимость, но большая задержка получения результата.
- Главные плюсы: легко повторять (replay), удобно пересчитывать при изменении логики, проще reasoning о корректности.
- Главные минусы: не подходит для интерактивных SLA, и часто требует тяжелых shuffle/sort этапов.

## Batch Processing with Unix Tools

- Unix-пайплайны — минималистичная форма batch: потоковый интерфейс (stdin/stdout), композиция маленьких утилит, прозрачность промежуточных шагов.
- Эта философия переносится на большие данные: стадийность, четкие интерфейсы, возможность быстро экспериментировать.

### Simple Log Analysis

- Типовая задача: фильтрация логов → извлечение полей → группировка → сортировка → агрегация.
- Даже локально часто упирается в сортировку (для группировки больших объемов) и в I/O.

### Chain of commands versus custom program

- Цепочка команд быстрее для прототипа и вариативности; кастомная программа может быть оптимальнее, когда понятны узкие места.
- Хорошая практика: сначала композиция и проверка гипотез, потом — оптимизация bottleneck стадий.

### Sorting versus in-memory aggregation

- Сортировка позволяет агрегировать огромные наборы через external sort, не храня все в RAM.
- In-memory агрегация быстрее, но ограничена памятью и чувствительна к skew (супер-популярные ключи).

### The Unix Philosophy

- Ключевые принципы: единый интерфейс, разделение логики и «проводки», прозрачность и экспериментирование.
- В дата-пайплайнах это означает: отделять трансформации от оркестрации и сохранять наблюдаемость промежуточных результатов.

## MapReduce and Distributed Filesystems

- MapReduce = map + shuffle/sort + reduce поверх распределенной файловой системы (DFS), где данные реплицируются для надежности.
- Основная идея масштабирования: много независимых map задач, затем группировка по ключу и reduce-агрегация.

### MapReduce Job Execution

- Map читает блоки входа (часто рядом с данными), пишет промежуточные пары key/value.
- Shuffle перегоняет и сортирует по ключу так, чтобы все значения одного ключа попали в один reducer.
- Сбои задач считаются нормой: scheduler перезапускает task, важны детерминизм и отсутствие внешних side effects.

## Reduce-Side Joins and Grouping

- Reduce-side join универсален: всё с одним ключом встречается в одном reducer после shuffle.
- Но он дорог из-за полного shuffle и сортировки — часто это главный «налог» MapReduce.

### Sort-merge joins

- Join реализуется как слияние отсортированных потоков по ключу: эффективно при больших данных, но требует сортировки/shuffle.
- Порядок и партиционирование по ключу становятся фундаментом производительности.

### GROUP BY

- GROUP BY в MapReduce — это частный случай: map формирует ключ, shuffle группирует, reduce агрегирует.
- Коммутативные/ассоциативные агрегаты можно частично считать до shuffle (combiner), уменьшая сетевой трафик.

### Handling skew

- Skew разрушает параллелизм: один тяжелый ключ перегружает reducer.
- Техники: salting ключей, отдельная обработка heavy hitters, двухфазная агрегация, переразбиение (custom partitioner).

## Map-Side Joins

- Map-side join избегает shuffle, если данные заранее совместно разложены или если один набор мал и может быть разослан.
- Это быстрее, но требует подготовки (партиционирование/сортировка) и аккуратных предположений о размере/формате.

### Broadcast hash joins

- Малый справочник загружается в память каждого mapper как hash-таблица; быстро, но ограничено RAM и размером справочника.

### Partitioned hash joins

- Обе стороны заранее партиционированы одинаково; каждый mapper обрабатывает свою пару партиций, избегая глобального shuffle.

### Map-side merge joins

- Если обе стороны уже отсортированы и совместно разбиты, join делается streaming-слиянием на map-стороне.

## The Output of Batch Workflows

- Batch-выход — это артефакт: индекс поиска, витрина аналитики, файл, или KV-состояние для online serving.
- Важно мыслить выходом как опубликованным продуктом: версия, схема, качество данных, идемпотентность записи.

### Key-value stores as batch process output

- Частый паттерн: batch вычисляет derived state и загружает его в KV-хранилище, чтобы онлайн-запросы были быстрыми.
- Это разделяет тяжелые вычисления и запросный путь (serving layer).

## Comparing Hadoop to Distributed Databases

- Hadoop/DFS-экосистема — про batch и устойчивость к частым падениям задач.
- Распределенные БД — про интерактивность, индексы и транзакции; разные компромиссы по latency и модели выполнения.

## Beyond MapReduce

- Ограничение MapReduce — обязательная материализация между стадиями (файлы на диск), что повышает надежность, но удорожает I/O и latency.
- DAG/dataflow-движки уменьшают материализацию, дают оптимизации и быстрее для итеративных задач.

### Materialization of Intermediate State*-

- Материализация полезна как контрольная точка (debug, replay, устойчивость), но дорого стоит на больших объемах.
- Альтернатива: lineage/recompute + checkpoints (как компромисс между скоростью и восстановлением).

## Graphs and Iterative Processing

- Итеративные алгоритмы плохо ложатся на MapReduce из-за повторного shuffle на каждой итерации.
- Модели типа Pregel держат состояние ближе к вершинам/партициям и синхронизируются супер-шагами.

## High-Level APIs and Languages

- Тренд: уход от низкоуровневого API к декларативным запросам (SQL/DataFrame), чтобы движок мог оптимизировать план.
- Также растет специализация: разные домены (ML, графы, стримы) требуют разной модели state/времени.

## Summary

- Batch — это про воспроизводимость и масштаб, где сортировка/shuffle — центральный механизм для join’ов и агрегатов.
- Современные системы смещаются к DAG/SQL-движкам и лучшей поддержке итеративности и оптимизаций.

---

## Термины

- **External sort:** сортировка с использованием диска при нехватке RAM
- **MapReduce:** модель вычислений: map + shuffle/sort + reduce
- **Shuffle:** перераспределение по ключу (сеть+сортировка), главный дорогой этап
- **Combiner:** частичная агрегация до shuffle для уменьшения трафика
- **Skew:** перекос распределения ключей/нагрузки
- **Reduce-side join:** join через shuffle (универсально, но дорого)
- **Map-side join:** join без shuffle при подготовленных данных/малой таблице
- **Serving layer:** онлайн слой, обслуживающий запросы на основе batch-выхода
- **Materialization:** запись промежуточных результатов как надежная контрольная точка
- **DAG engine:** движок исполнения графа операций с оптимизациями (lineage, pipelining)
