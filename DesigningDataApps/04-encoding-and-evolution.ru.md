# 4. Encoding and Evolution
[english](04-encoding-and-evolution.md) | russian

**TL;DR:** Как выбирать форматы сериализации и управлять эволюцией схем (backward/forward compatibility) при dataflow через БД, RPC/REST и сообщения.

---

## Formats for Encoding Data

- Формат влияет на размер, скорость, безопасность и совместимость; важен контракт (schema).

## Language-Specific Formats

- Сильно привязаны к языку/версиям; часто небезопасны и плохо совместимы межъязыково.

## JSON, XML, and Binary Variants

- Текстовые форматы удобны, но “толстые” и неоднозначны по типам; бинарные экономят место/CPU.

### Binary encoding

- Компактность и скорость ценой читаемости; важно договориться о типах и optional полях.

## Thrift and Protocol Buffers

- Schema‑first, генерация кода, бинарная сериализация; совместимость через field IDs.

### Field tags and schema evolution

- ID поля нельзя переиспользовать под другое значение; новые поля добавляй как optional/с дефолтом.

### Datatypes and schema evolution

- Смена типов опасна; безопаснее добавлять новое поле и мигрировать постепенно.

## Avro

- Writer/reader schemas + правила резолюции; удобно для событий и data pipelines.

### The writers schema and the readers schema

- Writer пишет по своей схеме, reader читает по своей; несовпадения “склеиваются” правилами.

### Schema evolution rules

- Backward‑совместимость часто достигается добавлением поля с дефолтом; удаление — если reader не требует.

### But what is the writers schema?

- Нужен способ доставки схемы: schema registry, заголовок сообщения, передается отдельно.

### Dynamically generated schemas

- Автогенерация облегчает ingestion, но требует дисциплины версионирования и именования.

### Code generation and dynamically typed languages

- В статических языках важна генерация типов; в динамических — валидация и контракт тестами.

## The Merits of Schemas

- Схемы дают валидацию, документацию и управляемую эволюцию; требуют governance.

## Modes of Dataflow

- Данные “текут” через БД, сервисы и сообщения; в каждом случае своя стратегия совместимости.

### Dataflow Through Databases

- Разные версии приложения читают/пишут в одну БД → нужно читать старое и новое, либо мигрировать.

#### Different values written at different times

- Старые записи остаются в старом формате; reader должен быть совместим по времени.

Стратегии работы:
- Lazy migration — преобразование записи при чтении
- Eager migration — массовая миграция через ALTER и обновление всех данных
- Поддержка нескольких форматов в переходный период

#### Archival storage

- Для архива важны самодокументируемость и стабильные форматы + метаданные. Форматы вроде Avro, Parquet или JSON со схемой подходят лучше, чем неформализованные бинарные форматы.

### Dataflow Through Services: REST and RPC

- REST проще и “грубее”; RPC быстрее и типизированнее, но сеть = timeouts/retries/частичные сбои.

#### Web services

- HTTP + контракт (OpenAPI/Swagger/JSON Schema) + версионирование API + коды ошибок + optional/required поля.

#### The problems with remote procedure calls (RPCs)

- Локальный вид скрывает сетевые проблемы: ретраи, дубли, непредсказуемые задержки.

#### Current directions for RPC

- Современные RPC (например, gRPC‑класс) = строгие схемы + явные политики таймаутов/ретраев.

#### Data encoding and evolution for RPC

- Делай эволюцию совместимой: optional поля, новые endpoints, контроль ошибок и idempotency.

### Message-Passing Dataflow

- Асинхронность снижает связность и помогает с буферизацией пиков; важны семантики доставки.

#### Message brokers

- Broker хранит/доставляет сообщения; выбирай семантику at‑least‑once и делай обработчики идемпотентными.

#### Distributed actor frameworks
В акторной модели:
- каждый актор имеет собственное состояние
- взаимодействие происходит только через сообщения
- отсутствует разделяемая память

Акторы обмениваются сообщениями; нужно учитывать порядок, повторную доставку и состояние.
Упрощают локальную логику, но не устраняют фундаментальные проблемы распределённых систем.

## Summary

- Управление схемами и совместимость — основа безопасных изменений в распределённых системах.
