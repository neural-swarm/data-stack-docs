# 11. Stream Processing
[english](11-stream-processing.md) | russian

**TL;DR:** Стримы, брокеры и лог-ориентированные очереди; CDC и event sourcing; время и окна; joins и состояние; отказоустойчивость через offsets/checkpoints и идемпотентность.

---

## Transmitting Event Streams

- Стримы — бесконечные последовательности событий; цель — непрерывно превращать события в обновления состояния/метрик/представлений.
- Передача стримов требует буферизации и управления скоростью (backpressure), иначе перегрузка приводит к лавине ретраев и росту lag.

## Messaging Systems

- Классический messaging опирается на подтверждения (acks) и повторную доставку (redelivery) при сбоях.
- Это почти всегда означает at-least-once: чтобы не получить двойной эффект, обработчик должен быть идемпотентным или иметь дедупликацию.

### Direct messaging from producers to consumers

- Прямые соединения уменьшают прослойки, но усложняют discovery, мультикаст, backpressure и управление множеством потребителей.
- При сбоях приходится самим решать буферизацию и повторы.

### Message brokers

- Брокер отделяет producers от consumers, буферизует пики, дает fan-out и упрощает эксплуатацию.
- Ключевые параметры: порядок (per-partition), retention, acks, DLQ, политика повторов.

## Partitioned Logs

- Лог-ориентированные брокеры хранят сообщения как append-only лог в партициях; потребители читают по offset.
- Это дает: replay истории, независимых потребителей, и естественную «точку истины» для событий.

### Consumer offsets

- Offset — курсор чтения; для «effectively once» нужно согласовать фиксацию offset с записью результата/состояния.
- Если offset фиксируется раньше — риск потери; если позже — риск дублей (но дубли лечатся идемпотентностью).

### When consumers cannot keep up with producers

- Если consumer lag растет, это сигнал перегрузки или неверного партиционирования ключей.
- Меры: масштабировать консьюмеров, менять key partitioning, оптимизировать state access, ограничивать producers, вводить rate limits.

### Replaying old messages

- Replay нужен для пересчета derived state, исправления багов и построения новых представлений.
- Требует: совместимости схем, версионирования логики, идемпотентности и понятной политики retention/compaction.

## Databases and Streams

- Потоки и БД дополняют друг друга: изменения БД можно транслировать как события (CDC), а поток можно материализовать в таблицы/индексы.
- Цель — держать системы синхронизированными без хрупких «двойных записей».

## Change Data Capture

- CDC читает журнал БД (WAL/binlog) и публикует изменения как поток.
- Сложности: начальный snapshot, точка согласования snapshot↔лог, порядок, schema evolution.

## Event Sourcing

- Event sourcing хранит события-факты как источник истины; текущее состояние — результат fold по логу.
- Плюсы: аудит и replay; минусы: рост истории, миграции, необходимость материализованных представлений для быстрых чтений.

### Commands and events

- Команда (command) — намерение и может быть отклонена; событие (event) — факт свершившегося изменения.
- Это разделение помогает строить валидации, идемпотентность и понятный аудит.

## State, Streams, and Immutability

- Иммутабельные события проще реплицировать и проверять: мы добавляем факты, а не переписываем прошлое.
- Ограничения: исправления/удаления (privacy), рост объема, необходимость компакции и снапшотов.

## Processing Streams

- Стрим-процессор держит состояние (state) и обновляет его на каждое событие; важна управляемая долговечность state.
- Многие ошибки стримов — это ошибки в управлении временем, порядком и восстановлением state.

### Uses of Stream Processing

- CEP (паттерны событий), stream analytics (агрегаты по окнам), поддержка materialized views, обновление поиска, интеграция сервисов.
- Во всех случаях критичны: обработка late events, порядок по ключу и идемпотентность.

## Reasoning About Time

- Event time (когда произошло) ≠ processing time (когда обработали). При задержках и переупорядочивании это меняет результаты агрегатов.
- Окна (windows) и watermarks позволяют формально сказать, когда «достаточно данных», и как поступать с опоздавшими событиями.

### Types of windows

- Tumbling (непересекающиеся), sliding (скользящие), session windows (по периодам активности).
- Выбор окна влияет на размер state и нагрузку на систему.

## Stream Joins

- Join в стримах требует хранить буфер событий (state) до закрытия окна; это увеличивает сложность и стоимость.
- Stream-table join (enrichment) требует версии справочника (as-of semantics), иначе результаты зависят от времени обновлений.

## Fault Tolerance

- Цель: после сбоя продолжить с согласованным состоянием и без неправильного двойного эффекта.
- Техники: checkpoints, microbatching, атомарная фиксация state+offset (или эквивалент), идемпотентность и дедупликация.

### Microbatching and checkpointing

- Microbatch упрощает консистентность: обрабатываем маленький батч событий как транзакцию.
- Checkpoint фиксирует state и позицию, чтобы восстановление было быстрым, но не слишком частым (компромисс cost/recovery).

### Idempotence

- Дубликаты неизбежны при at-least-once; делайте upsert/merge по ключу, используйте operation IDs и дедупликацию.
- Идемпотентность — главный практический способ «приблизиться» к exactly-once.

## Summary

- Стрим-процессинг = logs + state + time.
- Успех зависит от корректного управления offsets, checkpoints, окон и идемпотентности обработки.

