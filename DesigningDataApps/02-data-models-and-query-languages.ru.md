# 2. Data Models and Query Languages
[english](02-data-models-and-query-languages.md) | russian

**TL;DR:** Сравнение реляционной, документной и графовой моделей, причины NoSQL, и почему декларативные языки запросов важны для эволюции и оптимизации.

---

## Relational Model Versus Document Model

- Реляционная модель сильна в связях и ad‑hoc запросах (joins, агрегаты).
- Документы удобны для агрегатов (aggregate) и чтения “целого объекта” одним запросом.

## The Birth of NoSQL

- Драйверы: горизонтальное масштабирование, высокая доступность, гибкость схем, спец‑нагрузки.

## The Object-Relational Mismatch

- Разрыв между объектами приложения и таблицами: вложенность, коллекции, наследование.
- ORM помогает, но может скрывать дорогие N+1 и лишние joins.

## Many-to-One and Many-to-Many Relationships

- M:1 и M:N отношения проще выражать в реляционке; в документах часто нужны ссылки/доп. запросы.

## Are Document Databases Repeating History?

- Исторически существовали навигационные модели; SQL победил из‑за декларативности и оптимизаторов.

### The network model

- Навигация по указателям: быстро для заданных путей, плохо переносит изменения требований.

### The relational model

- Декларативные запросы отделяют “что” от “как”; оптимизатор выбирает план.

### Comparison to document databases

- Документы возвращают удобство агрегата/локальности, но сложнее для произвольных связей.

## Relational Versus Document Databases Today

- Системы сближаются (JSON в SQL, транзакции/индексы в NoSQL), но компромиссы остаются.

### Which data model leads to simpler application code?

- Агрегаты → документы проще; сложные связи/инварианты → реляционка часто проще.

### Schema flexibility in the document model

- Schema‑on‑read ускоряет изменения, но переносит контроль качества данных в приложение.

### Data locality for queries

- Вложенность улучшает locality; но обновления больших документов и частичные выборки могут дорожать.

### Convergence of document and relational databases

- Гибридные фичи снижают разрыв, но не отменяют различий в оптимизации и модели консистентности.

## Query Languages for Data

- Декларативные языки дают оптимизацию и устойчивость к изменениям.

### Declarative Queries on the Web

- SQL/CSS‑селекторы — примеры декларативности; они проще для оптимизации и безопаснее.

### MapReduce Querying

- MapReduce масштабируем, но многословен и неудобен для интерактивных запросов.

## Graph-Like Data Models

- Граф удобен, когда связи — “первый класс”: обходы, рекомендации, зависимости.

### Property Graphs

- Узлы/рёбра с произвольными свойствами; удобно для traversal‑запросов.

### The Cypher Query Language

- Декларативные шаблоны путей (pattern matching) поверх property graph.

### Graph Queries in SQL

- Можно моделировать граф таблицами, но рекурсивные обходы часто сложнее и дороже.

### Triple-Stores and SPARQL

- RDF хранит факты как (subject,predicate,object); SPARQL запрашивает граф шаблонами.

#### The semantic web

- Идея: связные данные и общие онтологии между доменами.

#### The RDF data model

- Триплеты как универсальный формат фактов.

#### The SPARQL query language

- Язык шаблонов/фильтров для RDF‑графов.

### The Foundation: Datalog

- Факты + правила вывода; хорош для рекурсивных отношений и объяснимых запросов.

## Summary

- Выбирай модель под структуру данных и типы запросов; декларативность облегчает эволюцию.
